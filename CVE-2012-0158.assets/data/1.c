#include<stdio.h>
#define EM(x) _asm _emit x
extern "C" int shellcode_start();
 
_declspec(naked) int shellcode_entry()
{
    _asm
    {
        nop
        nop
        nop
        nop
        nop
        jmp shellcode_start
        nop
    }
}
 
//获取Kernel32基地址
_declspec(naked) int GetKernel32Base()
{
    _asm
    {
        push esi
        mov esi,dword ptr fs : [0x30]//1.FS:[0x30]获取PEB
        mov esi,[esi + 0xc]//2.指向PEB_LDR_DATA结构指针
        mov esi,[esi + 0x1c]//3.模块链表指针
        mov esi,[esi]//4.获取第一个链表结构
        mov esi,[esi]//5.获取模块链表第二个条目，一般是kernel32或者kernelbase(win7以下)
        mov eax,[esi+0x8]//6.获取基址，kernel32或者kernelbase
        pop esi
        ret
    }
}
 
//求字符串Hash值
_declspec(naked) int GetStringHash(const char* szString)
{
    _asm
    {
        push ebp
        mov ebp,esp
        push esi
        push edx
        xor edx,edx
        xor eax,eax
        mov esi,[ebp+8]//获取参数，即字符串
    GetStringHash_Loop:
        lods byte ptr [esi] //获取字符串一个字节
        test al,al
        je GetStringHash_Exit//直到遇到0退出循环
        rol edx,0x3//求hash
        xor dl,al//求hash
        jmp GetStringHash_Loop
    GetStringHash_Exit:
        xchg eax,edx//将结果保存在eax
        pop edx
        pop esi
        mov esp,ebp
        pop ebp
        retn 4
    }
}
 
_declspec(naked) int GetHashAndCmpHash(const char*strFunName,int nHash)
{
    _asm
    {
        push ebp
        mov ebp,esp
        push ebx
        push edx
        mov eax,[ebp+0x8]//参数1：ebp+0x8 strFunName
        push eax
        call GetStringHash
        mov ebx,eax
        xor eax,eax
        mov edx,[ebp+0xc]//参数2 hash
        cmp ebx,edx//比较字符串的hash值
        jne GetHashAndCmpHash_End//不等返回0
        mov eax,0x1//相等返回1
    GetHashAndCmpHash_End:
        pop edx
        pop ebx
        mov esp,ebp
        pop ebp
        retn 8
    }
}
 
//根据hash值 寻找指定模块的 函数地址
_declspec(naked) int GetAddrFromHash(int nHash,int nImageBase)
{
    _asm
    {
        push ebp
        mov ebp,esp
        sub esp,0xc//申请局部空间
        push edx
        //1.获取EAT/ENT/EOT地址
        mov edx,[ebp+0xc] //imageBase
        mov esi,[edx+0x3c]//esi=IMAGE_DOS_HEADER.e_lfanew
        lea esi,[edx+esi]//pe文件头
        mov esi,[esi+0x78]//esi=IMAGE_EXPORT.VirtualAddress
        lea esi,[edx+esi]//esi=导出表首地址
        //EAT
        mov edi,[esi+0x1c]//edi=IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
        lea edi,[edx+edi]//EAT首地址
        mov [ebp-0x4],edi//EAT
        //ENT
        mov edi,[esi+0x20]//edi=IMAGE_EXPORT_DIRECTORY.AddressOfNames
        lea edi,[edx+edi]//ENT首地址
        mov [ebp-0x8],edi//ENT
        //EOT
        mov edi,[esi+0x24]//edi=IMAGE_EXPORT_DIRECTORY.AddressOfNamesOrdinals
        lea edi,[edx+edi]//EOT首地址
        mov [ebp-0xc],edi//EOT
        //2.循环对比ENT中的函数名
        xor ecx,ecx//数组下标
        jmp Loop_FirstCmp
    Loop_FunName:
        inc ecx
    Loop_FirstCmp:
        mov esi, [ebp - 0x8]//ent
        mov esi, [esi + ecx * 4]//ENT rva
        mov edx, [ebp + 0xc]//imageBase
        lea esi, [edx + esi]//ENT va(第一个函数名)
        push[ebp + 0x8]//nHash
        push esi//strFun
        call GetHashAndCmpHash
        test eax, eax
        je Loop_FunName
        //3.成功后找到对应序号
        mov esi, [ebp - 0xc]//EOT
        xor edi, edi
        mov di, [esi + ecx * 2]//取EOT[i]
        //4.在EAT中找到对应函数地址
        mov esi, [ebp - 0x4]//EAT
        mov edi, [esi + edi * 4]//EAT[EOT[i]] rva
        mov edx, [ebp + 0xc]//imageBase
        //5.返回地址
        lea eax, [edx + edi]//EAT VA函数地址
        pop edx
        mov esp,ebp
        pop ebp
        retn 8
    }
}
 
_declspec(naked) int shellcode_start()
{
    _asm
    {
        push ebp
        mov ebp,esp
        sub esp,0x30
        jmp zero_code
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        zero_code:
 
        jmp code_start
        //ebp-0x10(28) len:7"user32/0"
        EM(0x75) EM(0x73) EM(0x65) EM(0x72) EM(0x33) EM(0x32) EM(0x00)
        //ebp-0x0c(17) len:12"Hello World/0"
        EM(0x48) EM(0x65) EM(0x6C) EM(0x6C) EM(0x6F) EM(0x20) EM(0x57) EM(0x6F) EM(0x72) EM(0x6C) EM(0x64) EM(0x00)
    code_start:
        call code_pop
    code_pop:
        pop eax
        sub eax,0x18
        mov [ebp-0x2C],eax //保存user32地址
        add eax,0x7
        mov [ebp-0x28],eax//保存Hello World地址
 
        //1.获取Kernel32基地址
        call GetKernel32Base
        mov [ebp-0x24],eax
        //2.获取GetProcAddress地址
        push eax
        push 0xf2509b84
        call GetAddrFromHash
        mov [ebp-0x20],eax
        //3.获取LoadLibraryA地址
        push [ebp-0x24]
        push 0xa412fd89
        call GetAddrFromHash
        mov [ebp-0x1c],eax
        //4.获取user32基地址
        push [ebp-0x2c]
        call [ebp-0x1c]
        mov [ebp-0x18],eax
        //5.获取MessageBoxA地址
        push eax
        push 0x14d14c51
        call GetAddrFromHash
        mov [ebp-0x14],eax
        //6.调用MessageBoxA地址
        push 0
        push 0
        push [ebp-0x28]
        push 0
        call [ebp-0x14]
        //7.获取ExitProcess地址
        push [ebp-0x24]
        push 0xe6ff2cb9
        call GetAddrFromHash
        //8.调用ExitProcess
        push 0
        call eax
 
        retn
    }
}
int main()
{
    shellcode_entry();
    return 0;
}